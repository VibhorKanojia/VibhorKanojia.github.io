<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">

<!-- Begin Jekyll SEO tag v2.3.0 -->
<title>Heaps | VibhorKanojia.github.io</title>
<meta property="og:title" content="Heaps" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="&lt;!DOCTYPE HTML&gt; Heaps" />
<meta property="og:description" content="&lt;!DOCTYPE HTML&gt; Heaps" />
<link rel="canonical" href="http://localhost:4000/datastructures/heap.html" />
<meta property="og:url" content="http://localhost:4000/datastructures/heap.html" />
<meta property="og:site_name" content="VibhorKanojia.github.io" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-03-18T00:00:00+00:00" />
<script type="application/ld+json">
{"name":null,"description":"&lt;!DOCTYPE HTML&gt; Heaps","author":null,"@type":"BlogPosting","url":"http://localhost:4000/datastructures/heap.html","publisher":null,"image":null,"headline":"Heaps","dateModified":"2018-03-18T00:00:00+00:00","datePublished":"2018-03-18T00:00:00+00:00","sameAs":null,"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/datastructures/heap.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
     <link rel="stylesheet" href="/stylesheets/style.css?v=b3cb09d32d48c80fac975b1e932095ce30e4e6d7">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Heaps</h1>
      <h2 class="project-tagline"></h2>
    </section>
   
    <div>

    <section style="float:left" class="main-content">
      <!DOCTYPE HTML>
<html>
<head>
<title> Heaps</title>
</head>
<body>

<h3> Introduction </h3>
<p>Many a times we need a data structure which can be used to access elements based on certain criteria, for e.g., from smallest to largest element. A Heap or A Priority Queue is a data structure which stores elements in an orderly fashion, such that the element with highest priority is at the top of the heap.</p> 

<h3> Specifics </h3>
<p>Heaps are implemented using an array/vector with the root node at index 0. Any node at index i has children at indices 2*i+1 and 2*i+2 in the array. All nodes follow the constraint that a parent has more priority than its children. While adding a node, we add it at the end of the array and then move it upwards while the constraint is violated.</p>

<table>
  <tr>
    <th> Operation </th>
    <th>Time Complexity (Average Case)</th>
    <th>Time Complexity (Worst case)</th>
  </tr>
  <tr>
    <td> Insertion</td>
    <td>O(logN)</td>
    <td>O(logN)</td>
  </tr>
  <tr>
    <td> Get Top Element</td>
    <td>O(logN)</td>
    <td>O(logN)</td>
  </tr>
</table>

<h3> Implementation </h3>
<p>Implementation of the min/max heaps should not take more than 10 minutes. Below is the implementation of a min heap, i.e., a priority queue where priority is given to smaller elements.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cm">/* Function to swap the two elements at given indices */</span>
<span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">heap</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index2</span><span class="p">){</span>
    
    <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">heap</span><span class="p">[</span><span class="n">index1</span><span class="p">];</span>

    <span class="n">heap</span><span class="p">[</span><span class="n">index1</span><span class="p">]</span> <span class="o">=</span> <span class="n">heap</span><span class="p">[</span><span class="n">index2</span><span class="p">];</span>

    <span class="n">heap</span><span class="p">[</span><span class="n">index2</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>

    <span class="k">return</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/* Shifting upwards the element at the given index until it satifies the constraint */</span>
<span class="kt">void</span> <span class="n">shiftUp</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">heap</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">){</span>

    <span class="kt">int</span> <span class="n">par_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">index</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">par_index</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">){</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">heap</span><span class="p">[</span><span class="n">par_index</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">heap</span><span class="p">[</span><span class="n">index</span><span class="p">]){</span>

            <span class="n">swap</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="n">par_index</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>

            <span class="n">shiftUp</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="n">par_index</span><span class="p">);</span>

        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*Shifting downwards the element at the given index until it satisfies the constraint */</span>
<span class="kt">void</span> <span class="n">shiftDown</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">heap</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">){</span>
    
    <span class="kt">int</span> <span class="n">child1</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">child2</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">index</span><span class="o">+</span><span class="mi">2</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">min_child</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">child2</span> <span class="o">&lt;</span> <span class="n">heap</span><span class="p">.</span><span class="n">size</span><span class="p">()){</span>
            <span class="n">min_child</span> <span class="o">=</span> <span class="p">(</span><span class="n">heap</span><span class="p">[</span><span class="n">child1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">heap</span><span class="p">[</span><span class="n">child2</span><span class="p">])</span><span class="o">?</span> <span class="n">child1</span> <span class="o">:</span> <span class="n">child2</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">child1</span> <span class="o">&lt;</span> <span class="n">heap</span><span class="p">.</span><span class="n">size</span><span class="p">()){</span>
        <span class="n">min_child</span> <span class="o">=</span> <span class="n">child1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">min_child</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">heap</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">heap</span><span class="p">[</span><span class="n">min_child</span><span class="p">])</span> <span class="k">return</span><span class="p">;</span>
    
    <span class="n">swap</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">min_child</span><span class="p">);</span>

    <span class="n">shiftDown</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="n">min_child</span><span class="p">);</span>

    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Function to convert an array to a heap */</span>
<span class="cm">/* Heapify method appears to have O(NlogN) complexity but it is actually O(N) */</span>
<span class="kt">void</span> <span class="n">heapify</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">heap</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="n">heap</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span><span class="mi">0</span> <span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">){</span>
        <span class="n">shiftDown</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Function to add an element into the heap */</span>
<span class="kt">void</span> <span class="n">add</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">heap</span><span class="p">,</span> <span class="kt">int</span> <span class="n">elem</span><span class="p">){</span>
  
    <span class="n">heap</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">elem</span><span class="p">);</span>

    <span class="n">shiftUp</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="n">heap</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Function to accesss &amp; remove the smallest element from the heap */</span>
<span class="kt">int</span> <span class="n">getMin</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">heap</span><span class="p">){</span> 
    
    <span class="kt">int</span> <span class="n">min_elem</span> <span class="o">=</span> <span class="n">heap</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    
    <span class="kt">int</span> <span class="n">last_index</span> <span class="o">=</span> <span class="n">heap</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="n">heap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">heap</span><span class="p">[</span><span class="n">last_index</span><span class="p">];</span>

    <span class="n">heap</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">heap</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="n">shiftDown</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">min_elem</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<h5> Heapify </h5>
<p>To heapify an array means to convert an array into a heap. To do this, we start at the bottom ignoring all the leaves, and call shiftDown function on all the non-leaf nodes. But looking at the recursive call one may mistakenly assume it to be a O(NlogN) complexity method. But there is an upper bound on the number of steps a node can move downwards which makes this function have O(N) complexity.<br>

N -> Number of nodes in the heap;<br>
H -> Height of the heap;<br>
2<sup>i</sup> -> Nodes at level i (root is at level 0);<br>

Therefore, number of operations involved are:<br>

#O = 1*2<sup>H-1</sup> + 2*2<sup>H-2</sup> + 3*2<sup>H-3</sup> ... H*2<sup>0</sup>.<br>

#O = 2<sup>H</sup>* i/2<sup>i</sup>  (i = [1,H]). <br>

Now, i/2<sup>i</sup>  (i = [1,H])  <  i/2<sup>i</sup>  (i = [1,inf]). <br>
Right hand side is an AGP which sums up to 1. <br>
Hence, i/2<sup>i</sup>  (i = [1,H]) < 1. <br>

#O = 2<sup>H</sup> = O(N) (H = log(N)/log(2)) <br>





<h3> C++ STL Library </h3>
<p>C++ has its own STL library implementation of priority queues which can be used directly without implementing your own methods.
Below is an example where we want to access an employee database starting from the youngest employees.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#include &lt;priority_queue&gt;
</span>

<span class="cm">/* Struct which stores the employees' information */</span>
<span class="k">struct</span> <span class="n">Person</span><span class="p">{</span>
    <span class="n">string</span> <span class="n">name</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>
    <span class="n">Person</span><span class="p">(</span><span class="n">string</span> <span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">age</span><span class="p">){</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">age</span> <span class="o">=</span> <span class="n">age</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>


<span class="cm">/* Class function to decide the priority order */</span>
<span class="k">class</span> <span class="nc">Compare</span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="n">Person</span> <span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="n">Person</span> <span class="o">*</span> <span class="n">b</span><span class="p">){</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">age</span> <span class="o">&gt;</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">age</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>


<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>
    
    <span class="kt">int</span> <span class="n">N</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">N</span><span class="p">;</span>   <span class="c1">//Number of employees
</span>

    <span class="cm">/*&lt;datatype, container, comparator function&gt;*/</span>
    <span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">Person</span> <span class="o">*</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">Person</span> <span class="o">*&gt;</span><span class="p">,</span> <span class="n">Compare</span><span class="o">&gt;</span> <span class="n">heap</span><span class="p">;</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span><span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
    
        <span class="n">string</span> <span class="n">name</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">age</span><span class="p">;</span>

        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">name</span><span class="p">;</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">age</span><span class="p">;</span>

        <span class="n">Person</span> <span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Person</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">);</span>

        <span class="n">heap</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
    <span class="p">}</span>


    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">heap</span><span class="p">.</span><span class="n">empty</span><span class="p">()){</span>
        <span class="n">Person</span> <span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">heap</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
        
        <span class="n">cout</span><span class="o">&lt;&lt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">&lt;&lt;</span><span class="s">" "</span><span class="o">&lt;&lt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">age</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>

        <span class="n">heap</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>


<h3> Problems </h3>

</body>
</html>

    </section>
    
    <section style="float:right" class="main-content">
      
        <ul>
            
            <li>
                <a href="/content/ds.html">Basic Data Structures</a>
            </li>
            
            <li>
                <a href="/content/algo.html">Algorithms</a>
            </li>
            
            <li>
                <a href="/content/problems.html">Problems</a>
            </li>
            
            <li>
                <a href="/content/pvsnp.html">P vs NP</a>
            </li>
            
        </ul>
    </section>

      <footer class="site-footer">
        
          <span class="site-footer-owner"><a href="http://github.com/VibhorKanojia/VibhorKanojia.github.io">VibhorKanojia.github.io</a> is maintained by <a href="http://github.com/VibhorKanojia">VibhorKanojia</a>.</span>
        
        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a>.</span>
      </footer>

    </div>

    
  </body>
</html>
