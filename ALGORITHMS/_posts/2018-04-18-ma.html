---
layout: default
title: Morris Traversal
---


<!DOCTYPE HTML>
<html>
<head>
<title> {{ page.title }}</title>
</head>
<body>

<h3> Introduction </h3>
<p>As discussed before, there are various ways to traverse a binary tree. Inorder traversal is very popular as it visits nodes in a sorted manner if the tree is a binary search tree.</p>
<p>The common implementation of inorder traversal is by recursion. But recursive implementation is not considered to be O(1) space solution due to the recursion stack; it is in fact O(logN). Inorder traversal can also be implemented iteratively by using a stack data structure, but even this implementation will have O(N) space complexity. There exists an algorithm called Morris Traversal which guarantees iterative inorder traversal of a binary tree with O(1) space complexity.</p> 
<p> Note that this is a slightly advanced algorithm and should be considered only when the normal recursive implementation results in TLE.</p>

<h3> Complexity </h3>
<table>
  <tr>
    <th>Time Complexity (Worst case)</th>
    <th>Space Compexity (Worst case)</th>
  </tr>
  <tr>
    <td>O(N)</td>
    <td>O(1)</td>
  </tr>
</table>

<h3> Specifics </h3>

Morris traveral works by creating a threaded binary tree where we create a link from one node to its inorder successor

<h4> Iterative </h4>

{% highlight c %}

bool binarySearch(vector<int> array, int target){
    
    int start = 0;
    int end = array.size();

    while (start < end){
        int mid = start + (end-start)/2;
        if (array[mid] == target) return true;
        if (array[mid] > target) end = mid;
        else start = mid;
    }

    return false;
}

{% endhighlight %}

<h4> Recursive </h4>
{% highlight c %}

//Note that in the following implementation array is sorted, start is inclusive, end is exclusive.

bool binarySearch(vector<int> array, int start, int end, int target){
    
    if (start >= end) return false;

    int mid = start + (end-start)/2;

    if (array[mid] == target) return true;

    else if (array[mid] > target) return binarySearch(array,start,mid,target);

    else return binarySearch(array,mid,end,target);
}

{% endhighlight %}

<h3> Quiz </h3>

<ul>
    <li> Why don't we calculate mid as (start+end)/2 ?</li>
    <li> Why is Binary Search preferred over Ternary Search? What are the number of comparisons in both the cases?</li>
    <li> Worst case time complexity to find if the target exits in an array? </li>
    <li> Worst case time complexity to find if the target exists in a sorted array? </li>
    <li> Worst case time complexity to find the indices of the target in a sorted array? </li>
    <li> How would you modify the code to make end inclusive in both the implementations?</li>
</ul>

<h4> Questions </h4>


<table>
  <tr>
    <th>Title</th>
    <th>LeetCode</th>
    <th>C++ Solution</th>
  </tr>
  {% for post in site.tags.DFS %}
  <tr>
      <td>{{post.title}}</td>
      <td><a href={{post.leetcode}}>Link</a></td>
      <td><a href={{post.solution}}>Link</a></td>
  </tr>  
  {% endfor %}
</table>
</body>
</html>
