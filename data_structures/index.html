<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="author" content="Vibhor Kanojia">
    <meta name="description" content="Vibhor&#39;s personal space">
    <meta name="keywords" content="blog,developer,personal">

    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Data_structures"/>
<meta name="twitter:description" content="Vibhor&#39;s personal space"/>


    <base href="http://vibhorkanojia.github.io/data_structures/">
    <title>
  Data_structures · vibhor kanojia
</title>

    <link rel="canonical" href="http://vibhorkanojia.github.io/data_structures/">

    <link href="https://fonts.googleapis.com/css?family=Lato:400,700|Merriweather:300,700|Source+Code+Pro:400,700" rel="stylesheet">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css" integrity="sha256-oSrCnRYXvHG31SBifqP2PM1uje7SJUyX0nTwO2RJV54=" crossorigin="anonymous" />

    
      
      
      <link rel="stylesheet" href="http://vibhorkanojia.github.io/css/coder.min.ac37073bc2826cd28ef57364a9fe339de7ebcb26dafc22fd832cb35cf5b1d048.css" integrity="sha256-rDcHO8KCbNKO9XNkqf4znefryyba/CL9gyyzXPWx0Eg=" crossorigin="anonymous" media="screen" />
    

    

    

    

    <link rel="icon" type="image/png" href="http://vibhorkanojia.github.io/images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="http://vibhorkanojia.github.io/images/favicon-16x16.png" sizes="16x16">

    
      <link href="http://vibhorkanojia.github.io/data_structures/index.xml" rel="alternate" type="application/rss+xml" title="vibhor kanojia" />
      <link href="http://vibhorkanojia.github.io/data_structures/index.xml" rel="feed" type="application/rss+xml" title="vibhor kanojia" />
    

    <meta name="generator" content="Hugo 0.53" />
  </head>

  <body class=" ">
    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="http://vibhorkanojia.github.io">
      vibhor kanojia
    </a>
    <input type="checkbox" id="menu-toggle" />
    <label class="menu-button float-right" for="menu-toggle"><i class="fas fa-bars"></i></label>
    <ul class="navigation-list">
      
        
          <li class="navigation-item">
            <a class="navigation-link" href="http://vibhorkanojia.github.io/">Home</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="http://vibhorkanojia.github.io/posts/">Blogs</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="http://vibhorkanojia.github.io/about/">About</a>
          </li>
        
      
      
    </ul>
  </section>
</nav>


      <div class="content">
        
  <section class="container list">
    <h1 class="title">Data Structures</h1>

    <ul><li>
  <a class="title" href="http://vibhorkanojia.github.io/data_structures/vector/">Vector</a>
  <span class="date">January 20, 2019</span>
  <div style="font-size: 15px"> <p><p>Vectors are same as dynamic arrays with the ability to resize themselves automatically when an element is inserted or deleted, with their storage being handled automatically by the container. Vector elements are placed in contiguous storage so that they can be accessed and traversed using iterators in O(1) time.</p> </div>
</li>
<li>
  <a class="title" href="http://vibhorkanojia.github.io/data_structures/heap/">Heap</a>
  <span class="date">January 20, 2019</span>
  <div style="font-size: 15px"> <p>Many a times we need a data structure which can be used to access elements based on certain criteria, for e.g., from smallest to largest element. A Heap or A Priority Queue is a data structure which stores elements in an orderly fashion, such that the element with highest priority is at the top of the heap.</p> </div>
</li>
<li>
  <a class="title" href="http://vibhorkanojia.github.io/data_structures/avl_tree/">AVL Tree</a>
  <span class="date">January 20, 2019</span>
  <div style="font-size: 15px"> <p>Binary Trees provide O(logN) average case time complexity for insert, delete, and search operations. But depending upon the order of insert, we might form an unbalanced tree which makes the time complexity linear. AVL Trees are self-balancing binary trees that can guarantee O(logN) time complexity even in the worst case. The only drawback is that the structure of the tree changes as we add more and more nodes. </p> </div>
</li>
<li>
  <a class="title" href="http://vibhorkanojia.github.io/data_structures/disjoint_set/">Disjoint Set</a>
  <span class="date">January 20, 2019</span>
  <div style="font-size: 15px"> <p>Facebook has more than 2 billion users and, very often, given two users A and B, Facebook needs to find if A and B are connected. Such information can be really useful in features like friend suggestions, privacy protections, and various data analysis tasks.</p>
<p>One way to approach this problem is by doing a BFS, starting with A as source node and expanding the graph by visiting A's friends and stopping the search when we reach B. This approach will work for small datasets, but when you consider over 2 billion users each having around 500 friends, BFS ends up using a lot of space, and unnecessary expansion of graph leads to performance degradation. For example, imagine a scenario where A is infact not connnected to B! </p>
<p>One can think of various optimizations to improve the performance, and develop better heuristics to guide the graph expansion (A* algorithm), but it still won't give the satisfactory results. Keep in mind that the graph is not static, and the graph may have new connections over time.</p>
<p> What if we could answer this query in O(logN) time? Even better, what if we could answer this query in O(1) time?</p>
<p><i>Disjoint Sets to the rescue</i></p> </div>
</li>
<li>
  <a class="title" href="http://vibhorkanojia.github.io/data_structures/binary_tree/">Binary Tree</a>
  <span class="date">January 20, 2019</span>
  <div style="font-size: 15px"> <p>Unlike Arrays, Linked Lists, Stacks and Queues, which are linear data structures, trees are hierarchical data structures. Many real world datasets are hierarchical by nature and it makes more sense to store them in a tree data structure. I'll be discussing a special type of trees, Binary Trees.</p> </div>
</li>
<li>
  <a class="title" href="http://vibhorkanojia.github.io/data_structures/array/">Array</a>
  <span class="date">January 20, 2019</span>
  <div style="font-size: 15px"> <p>In C++, arrays can be used to store a collection of elements having the same type, where each element is uniquely identified by an index. Elements in an array are stored consecutively, and hence, given the address of the first element, the address of each element can be calculated using a mathematical formula. This provides O(1) access to each element of the array.</p>
<p>The size of an array means the number of elements it can hold.</p> </div>
</li>
</ul>

    






  </section>

      </div>

      <footer class="footer">
  <section class="container">
    
     © 2019
    
       · 
      Powered by <a href="https://gohugo.io/">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/">Coder</a>.
    
    
  </section>
</footer>

    </main>

    

  </body>

</html>
