<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">

<!-- Begin Jekyll SEO tag v2.3.0 -->
<title>Binary Trees | VibhorKanojia.github.io</title>
<meta property="og:title" content="Binary Trees" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="&lt;!DOCTYPE HTML&gt; Binary Trees" />
<meta property="og:description" content="&lt;!DOCTYPE HTML&gt; Binary Trees" />
<link rel="canonical" href="http://localhost:4000/Blog/datastructures/binarytree.html" />
<meta property="og:url" content="http://localhost:4000/Blog/datastructures/binarytree.html" />
<meta property="og:site_name" content="VibhorKanojia.github.io" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-03-18T00:00:00+05:30" />
<script type="application/ld+json">
{"name":null,"description":"&lt;!DOCTYPE HTML&gt; Binary Trees","author":null,"@type":"BlogPosting","url":"http://localhost:4000/Blog/datastructures/binarytree.html","publisher":null,"image":null,"headline":"Binary Trees","dateModified":"2018-03-18T00:00:00+05:30","datePublished":"2018-03-18T00:00:00+05:30","sameAs":null,"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/Blog/datastructures/binarytree.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="/Blog/stylesheets/style.css?v=43c1635ad51799f04c46f5a174ce51fe362202ba">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Binary Trees</h1>
      <h2 class="project-tagline"></h2>
    </section>
   
    <div>

    <section style="float:left" class="main-content">
      <!DOCTYPE HTML>
<html>
<head>
<title> Binary Trees</title>
</head>
<body>

<h3> Introduction </h3>
<p>Unlike Arrays, Linked Lists, Stacks and Queues, which are linear data structures, trees are hierarchical data structures. Many real world datasets are hierarchical by nature and it makes more sense to store them in a tree data structure. I'll be discussing a special type of trees, Binary Trees.</p> 

<h3> Types </h3>
Binary Trees have only one root node, and each node has at most two children nodes. Following are common types of Binary Trees:
<ul>
    <li><b>Full Binary Tree:</b> A Binary Tree is full if every node has zero or two children. In such a tree, #Leaves = #InternalNodes + 1</li>
    <li><b>Complete Binary Tree:</b> A Binary Tree is complete Binary Tree if all levels are completely filled except possibly the last level and the last level has all keys as left as possible</li>
    <li><b>Perfect Binary Tree:</b> A Binary tree is Perfect Binary Tree in which all internal nodes have two children and all leaves are at same level. Such a tree has 2<sup>h</sup>-1 nodes, where h is the height of the tree</li>
    <li><b>Degenerate Tree:</b> A Tree where every internal node has one child. Such trees are performance-wise same as linked list</li>
</ul>    

<h3> Binary Search Trees </h3>
<p>A Binary Search Tree additionally satisfies the binary search property, which states that the key in each node must be greater than or equal to any key stored in the left sub-tree, and less than or equal to any key stored in the right sub-tree. This property really improves the average case time complexity for inserting, deleting, searching a node in the data structure. However, the complexity doesn't change in the worst case scenario where the tree is a Degenerate tree.</p>

<table>
  <tr>
    <th> Operation </th>
    <th>Time Complexity (Average Case)</th>
    <th>Time Complexity (Worst case)</th>
  </tr>
  <tr>
    <td> Insertion</td>
    <td>O(logN)</td>
    <td>O(N)</td>
  </tr>
  <tr>
    <td> Deletion</td>
    <td>O(logN)</td>
    <td>O(N)</td>
  </tr>
  <tr>
    <td> Search</td>
    <td>O(logN)</td>
    <td>O(N)</td>
  </tr>
</table>

<h3> Implementation </h3>
Implementation of the above three operations should not take more than 10 minutes.

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">struct</span> <span class="n">Node</span><span class="p">{</span>
    <span class="kt">int</span> <span class="n">key</span><span class="p">;</span>
    <span class="n">Node</span> <span class="o">*</span> <span class="n">left</span><span class="p">;</span>
    <span class="n">Node</span> <span class="o">*</span> <span class="n">right</span><span class="p">;</span>
    <span class="n">Node</span> <span class="o">*</span> <span class="n">parent</span><span class="p">;</span>
    <span class="n">Node</span><span class="p">(</span><span class="kt">int</span> <span class="n">key</span><span class="p">,</span> <span class="n">Node</span> <span class="o">*</span> <span class="n">parent</span><span class="p">){</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="p">;</span>
        <span class="n">left</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">right</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="n">Node</span> <span class="o">*</span> <span class="n">insert</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">,</span> <span class="n">Node</span> <span class="o">*</span> <span class="n">parent</span><span class="p">){</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">&gt;=</span> <span class="n">val</span><span class="p">)</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>

    <span class="k">else</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Node</span> <span class="o">*</span> <span class="n">search</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">){</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">==</span> <span class="n">val</span><span class="p">)</span> <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
    
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">&gt;</span> <span class="n">val</span><span class="p">)</span> <span class="k">return</span> <span class="n">search</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
    
    <span class="k">else</span> <span class="k">return</span> <span class="n">search</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* This function finds the biggest node in the subtree rooted at this node */</span>
<span class="n">Node</span> <span class="o">*</span> <span class="n">findMax</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span> <span class="n">node</span><span class="p">){</span>
   <span class="n">Node</span> <span class="o">*</span> <span class="n">cur_node</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
   
   <span class="k">while</span> <span class="p">(</span><span class="n">cur_node</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="n">cur_node</span> <span class="o">=</span> <span class="n">cur_node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
   
   <span class="k">return</span> <span class="n">cur_node</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span> <span class="n">n1</span><span class="p">,</span> <span class="n">Node</span> <span class="o">*</span> <span class="n">n2</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">n1</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">;</span>
    <span class="n">n1</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">=</span> <span class="n">n2</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">;</span>
    <span class="n">n2</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This function deletes the node and returns the new node that takes its place */</span>
<span class="n">Node</span> <span class="o">*</span> <span class="k">delete</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span> <span class="n">node</span><span class="p">){</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
    
    <span class="n">Node</span> <span class="o">*</span> <span class="n">new_root</span> <span class="o">=</span> <span class="n">findMax</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
    
    <span class="n">swap</span><span class="p">(</span><span class="n">new_root</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
    
    <span class="p">(</span><span class="n">new_root</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="k">delete</span><span class="p">(</span><span class="n">new_root</span><span class="p">);</span>
    
    <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<h3> Tree Traversal </h3>
There are various ways to traverse a binary tree. Following are the most important traversal techniques:
<h4> In-order traversal </h4>
<i>Traverse the left-subtree, visit the current node, traverse the right subtree.</i>
<p>In-order traversal is really useful when traversing a binary search tree, as the nodes are visited in a sorted manner.</p>
<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cm">/* Prints the in-order traversal of a binary tree */</span>
<span class="kt">void</span> <span class="n">inorder</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span> <span class="n">node</span><span class="p">){</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

    <span class="n">inorder</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>

    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">key</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>

    <span class="n">inorder</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>

    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>


<h4> Pre-order traversal </h4>
<i>Visit the current node, traverse the left subtree, traverse the right subtree.</i>
<p>Pre-order traversal is used when you want to make changes to a tree recursively starting at the parent, and moving towards the children. It can be seen as a top-down recursive approach</p>
<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cm">/* Prints the pre-order traversal of a binary tree */</span>
<span class="kt">void</span> <span class="n">preorder</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span> <span class="n">node</span><span class="p">){</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">key</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
    
    <span class="n">preorder</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>

    <span class="n">preorder</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>

    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<h4> Post-order traversal </h4>
<i>Traverse the left subtree, traverse the right subtree, visit the current node.</i>
<p>Post-order traversal is used when you want to make changes to a tree recursively starting at the children, and moving towards the parent. It can be seen as a bottom-up recursive approach</p>
<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cm">/* Prints the post-order traversal of a binary tree */</span>
<span class="kt">void</span> <span class="n">postorder</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span> <span class="n">node</span><span class="p">){</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

    <span class="n">postorder</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>

    <span class="n">postorder</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>

    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">key</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
    
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<h4> Level-order traversal </h4>
<i>Traverse the tree one level at a time..</i>
<p>Level-order traversal is used when you want to visit all the nodes at height i before moving towards height i-1. Leaves have height = 0. General implementation is covered in the Breadth First Search algorithm. </p>

<h3> Quiz </h3>
<ul>
    <li> In a full binary tree, all nodes except leaves have two children. True or False? </li>
    <li> Every complete binary tree is a full binary tree and vice-versa? Tree or False? </li>
    <li> If we reverse the order of nodes in pre-order traversal, we get post-order traversal. True or False? </li>
    <li> In the delete function, instead of selecting the biggest node in the left sub-tree, we can also select the smallest node in the right sub-tree. True or False?</li>
    <li> How would you implement the delete function if you cannot store the parent information?</li>
    <li> If the Node struct has height variable, how would you update it while inserting or deleting a node? </li>
</ul>

<h3> Problems </h3>

</body>
</html>

    </section>
    
    <section style="float:right" class="main-content">
      
        <ul>
            
            <li>
                <a href="/content/ds.html">Basic Data Structures</a>
            </li>
            
            <li>
                <a href="/content/algo.html">Algorithms</a>
            </li>
            
            <li>
                <a href="/content/problems.html">Problems</a>
            </li>
            
            <li>
                <a href="/content/pvsnp.html">P vs NP</a>
            </li>
            
        </ul>
    </section>

      <footer class="site-footer">
        
          <span class="site-footer-owner"><a href="http://github.com/VibhorKanojia/VibhorKanojia.github.io">VibhorKanojia.github.io</a> is maintained by <a href="http://github.com/VibhorKanojia">VibhorKanojia</a>.</span>
        
        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a>.</span>
      </footer>

    </div>

    
  </body>
</html>
